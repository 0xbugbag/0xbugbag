<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>beo_hijau | Welcome</title><link href="http://localhost:8000/" rel="alternate"></link><link href="http://localhost:8000/feeds/all.atom.xml" rel="self"></link><id>http://localhost:8000/</id><updated>2024-12-02T15:00:00+07:00</updated><subtitle>Berani Bermimpi</subtitle><entry><title>Introduction to Machine Learning with Pacmann</title><link href="http://localhost:8000/2024/12/machine-learning-project-with-pacmann-1/" rel="alternate"></link><published>2024-12-02T15:00:00+07:00</published><updated>2024-12-02T15:00:00+07:00</updated><author><name>0xbugbag</name></author><id>tag:localhost,2024-12-02:/2024/12/machine-learning-project-with-pacmann-1/</id><summary type="html">&lt;p&gt;In this post, I have learned to prepare datasets for use in machine learning.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;!/usr/bin/env python&lt;/h1&gt;
&lt;h1&gt;coding: utf-8&lt;/h1&gt;
&lt;h1&gt;# Mentoring 1 - Introduction to Machine Learning&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;Mentoring Session - Job Preparation Program - Pacmann AI&lt;/h1&gt;
&lt;h1&gt;## Instructions&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;1. Please fill all the given tasks in here&lt;/h1&gt;
&lt;h1&gt;2. You can use any library&lt;/h1&gt;
&lt;h1&gt;3. For modeling, please use &lt;code&gt;sklearn&lt;/code&gt; library&lt;/h1&gt;
&lt;h1&gt;4. You are taksed to create a function based machine learning model. (If you cannot create the functions from the start, you can create without a function first, then put it all into a function)&lt;/h1&gt;
&lt;h1&gt;5. Make sure you are following all the function descriptions&lt;/h1&gt;
&lt;h1&gt;6. Submit your result to the submission form&lt;/h1&gt;
&lt;h1&gt;## Dataset Description&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;- This dataset originally comes from &lt;a href="https://www.kaggle.com/datasets/yasserh/uber-fares-dataset"&gt;Uber Fares Dataset&lt;/a&gt;&lt;/h1&gt;
&lt;h1&gt;- We perform several edit for this mentoring purposes. So, please use the dataset from &lt;a href="https://drive.google.com/file/d/1-Fr3OMbI1yKU_jNy-6cgXFJDVzjph3sn/view?usp=sharing"&gt;here&lt;/a&gt;.&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;
&lt;h1&gt;- We're looking to predict the fare of Uber's transactions.&lt;/h1&gt;
&lt;h1&gt;- The dataset contains of the following fields&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;&lt;center&gt;&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;|Feature|Type|Descriptions|&lt;/h1&gt;
&lt;h1&gt;|:--|:--|:--|&lt;/h1&gt;
&lt;h1&gt;|&lt;code&gt;order_id&lt;/code&gt;| &lt;code&gt;int&lt;/code&gt; | a unique identifier for each trip|&lt;/h1&gt;
&lt;h1&gt;|&lt;code&gt;pickup_time&lt;/code&gt; | &lt;code&gt;str&lt;/code&gt; | a class of pickup time. &lt;code&gt;04-10&lt;/code&gt;, &lt;code&gt;10-16&lt;/code&gt;, &lt;code&gt;16-22&lt;/code&gt;, &lt;code&gt;22-04&lt;/code&gt;. E.g. &lt;code&gt;04-10&lt;/code&gt; means the pickup time is between 04.00 to 10.00|&lt;/h1&gt;
&lt;h1&gt;| &lt;code&gt;pickup_longitude&lt;/code&gt; | &lt;code&gt;float&lt;/code&gt; | the longitude where the meter was engaged|&lt;/h1&gt;
&lt;h1&gt;| &lt;code&gt;pickup_latitude&lt;/code&gt; | &lt;code&gt;float&lt;/code&gt; | the latitude where the meter was engaged|&lt;/h1&gt;
&lt;h1&gt;| &lt;code&gt;dropoff_longitude&lt;/code&gt; | &lt;code&gt;float&lt;/code&gt; | the longitude where the meter was disengaged|&lt;/h1&gt;
&lt;h1&gt;| &lt;code&gt;dropoff_latitude&lt;/code&gt; | &lt;code&gt;float&lt;/code&gt; | the latitude where the meter was disengaged|&lt;/h1&gt;
&lt;h1&gt;| &lt;code&gt;passenger_count&lt;/code&gt; | &lt;code&gt;float&lt;/code&gt; | the number of passengers in the vehicle (driver entered value)|&lt;/h1&gt;
&lt;h1&gt;| &lt;code&gt;fare_amount&lt;/code&gt; | &lt;code&gt;int&lt;/code&gt; | the cost of each trip in USD, (&lt;strong&gt;our target&lt;/strong&gt;)|&lt;/h1&gt;
&lt;h1&gt;## Modeling Workflow&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;```&lt;/h1&gt;
&lt;h1&gt;1. Import data to Python&lt;/h1&gt;
&lt;h1&gt;2. Data Preprocessing&lt;/h1&gt;
&lt;h1&gt;3. Training a Machine Learning Models&lt;/h1&gt;
&lt;h1&gt;4. Test Prediction&lt;/h1&gt;
&lt;h1&gt;```&lt;/h1&gt;
&lt;h1&gt;### 1. Import data to Python (10 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;In[2]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Import Numpy and Pandas library&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.metrics import mean_squared_error
from sklearn.dummy import DummyRegressor
from sklearn.neighbors import KNeighborsRegressor&lt;/p&gt;
&lt;h1&gt;In[3]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Create a function named read_data&lt;/h1&gt;
&lt;h1&gt;- Has an input of filename, i.e. fname&lt;/h1&gt;
&lt;h1&gt;- Read the data as a Pandas DataFrame&lt;/h1&gt;
&lt;h1&gt;- Drop duplicate on &lt;code&gt;order_id&lt;/code&gt;, keep the last ones&lt;/h1&gt;
&lt;h1&gt;- Set &lt;code&gt;order_id&lt;/code&gt; as index&lt;/h1&gt;
&lt;h1&gt;- Print the data shape&lt;/h1&gt;
&lt;h1&gt;- Return the dataset&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;def read_data(fname):
    """
    Read and preprocess the dataset.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Parameters&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;The&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;be&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;read&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="k"&gt;Returns&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;The&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;processed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataset&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;with open(fname, &amp;#39;r&amp;#39;) as f: &lt;/span&gt;
&lt;span class="s2"&gt;    df = pd.read_csv(f, sep=&amp;#39;,&amp;#39;, header=0)&lt;/span&gt;
&lt;span class="s2"&gt;    print(f&amp;#39;Data shape rawd: {df.shape}&amp;#39;)&lt;/span&gt;

&lt;span class="s2"&gt;    # Drop duplicate on `order_id`, keep the last ones&lt;/span&gt;
&lt;span class="s2"&gt;    # Set `order_id` as index&lt;/span&gt;
&lt;span class="s2"&gt;    df = df.drop_duplicates(subset=&amp;#39;order_id&amp;#39;, keep=&amp;#39;last&amp;#39;) &lt;/span&gt;
&lt;span class="s2"&gt;    df_count_dup = df.duplicated(subset=&amp;#39;order_id&amp;#39;).sum()&lt;/span&gt;
&lt;span class="s2"&gt;    print(f&amp;#39;Number of duplicate order id: {df_count_dup}&amp;#39;)&lt;/span&gt;
&lt;span class="s2"&gt;    print(f&amp;#39;Data shape after dropping: {df.shape}&amp;#39;)&lt;/span&gt;

&lt;span class="s2"&gt;    df =df.set_index(&amp;#39;order_id&amp;#39;, inplace=False)&lt;/span&gt;
&lt;span class="s2"&gt;    print(f&amp;#39;Data shape final: {df.shape}&amp;#39;)&lt;/span&gt;

&lt;span class="s2"&gt;    return df&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;In[3]:&lt;/h1&gt;
&lt;h1&gt;Read the Uber data (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;data = read_data(fname='uber_edit.csv')&lt;/p&gt;
&lt;h1&gt;In[4]:&lt;/h1&gt;
&lt;h1&gt;JUST RUN THE CODE&lt;/h1&gt;
&lt;p&gt;data.head()&lt;/p&gt;
&lt;h1&gt;### 2. Data Preprocessing (60 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;&lt;strong&gt;The processing pipeline&lt;/strong&gt;&lt;/h1&gt;
&lt;h1&gt;```&lt;/h1&gt;
&lt;h1&gt;2.1 Input-Output Split&lt;/h1&gt;
&lt;h1&gt;2.2 Train-Valid-Test Split&lt;/h1&gt;
&lt;h1&gt;2.3 Separate Numerical and Categorical Features&lt;/h1&gt;
&lt;h1&gt;2.4 Numerical Imputation&lt;/h1&gt;
&lt;h1&gt;2.5 Categorical Imputation&lt;/h1&gt;
&lt;h1&gt;2.6 Preprocess Categorical Features&lt;/h1&gt;
&lt;h1&gt;2.7 Join the Data&lt;/h1&gt;
&lt;h1&gt;2.8 Feature Engineering the Data&lt;/h1&gt;
&lt;h1&gt;2.9 Create a Preprocessing Function&lt;/h1&gt;
&lt;h1&gt;```&lt;/h1&gt;
&lt;h1&gt;#### 2.1. Input-Output Split (6 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;- We're going to split input &amp;amp; output according to the modeling objective.&lt;/h1&gt;
&lt;h1&gt;- Create a function to split the input &amp;amp; output&lt;/h1&gt;
&lt;h1&gt;In[5]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Create a function named split_input_output&lt;/h1&gt;
&lt;h1&gt;- Has two arguments&lt;/h1&gt;
&lt;h1&gt;- data, a pd Dataframe&lt;/h1&gt;
&lt;h1&gt;- target_col, a column (str)&lt;/h1&gt;
&lt;h1&gt;- Print the data shape after splitting&lt;/h1&gt;
&lt;h1&gt;- Return X, y&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;def split_input_output(data, target_col):
    """
    Splits the input data into features (X) and target (y).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;Parameters&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;The&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataset&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;target_col&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;The&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;column&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="k"&gt;Returns&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;The&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;feature&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Series&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;The&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;column&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="ss"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;drop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;=[&lt;/span&gt;&lt;span class="n"&gt;target_col&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;target_col&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;X shape: {X.shape}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;y shape: {y.shape}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;In[6]:&lt;/h1&gt;
&lt;h1&gt;Load the train data only (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;X, y = split_input_output(data=data,
                          target_col='fare_amount')&lt;/p&gt;
&lt;h1&gt;In[7]:&lt;/h1&gt;
&lt;p&gt;X.head()  # (JUST RUN THE CODE)&lt;/p&gt;
&lt;h1&gt;In[8]:&lt;/h1&gt;
&lt;p&gt;y.head()  # (JUST RUN THE CODE)&lt;/p&gt;
&lt;h1&gt;#### 2.2. Train-Valid-Test Split (6 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;- Now, we want to split the data before modeling.&lt;/h1&gt;
&lt;h1&gt;- Split the data into three set:&lt;/h1&gt;
&lt;h1&gt;- Train, for training the model&lt;/h1&gt;
&lt;h1&gt;- Validation, for choosing the best model&lt;/h1&gt;
&lt;h1&gt;- Test, for error generalization&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;- You should make the splitting proportion train (80%), valid (10%), and test (10%)&lt;/h1&gt;
&lt;h1&gt;In[9]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Create a function named split_train_test&lt;/h1&gt;
&lt;h1&gt;- Has two arguments&lt;/h1&gt;
&lt;h1&gt;- X, the input (pd.Dataframe)&lt;/h1&gt;
&lt;h1&gt;- y, the output (pd.Dataframe)&lt;/h1&gt;
&lt;h1&gt;- test_size, the test size between 0-1 (float)&lt;/h1&gt;
&lt;h1&gt;- seed, the random state (int)&lt;/h1&gt;
&lt;h1&gt;- Print the data shape after splitting&lt;/h1&gt;
&lt;h1&gt;- Return X_train, X_test, y_train, y_test&lt;/h1&gt;
&lt;h1&gt;- You can use an sklearn library to help you&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;def split_train_test(X, y, test_size, seed):
    """
    Split the input data (X) and target data (y) into train and test sets.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Parameters:
&lt;span class="k"&gt;-&lt;/span&gt; X (pd.DataFrame): The input features.
&lt;span class="k"&gt;-&lt;/span&gt; y (pd.DataFrame or pd.Series): The target labels.
&lt;span class="k"&gt;-&lt;/span&gt; test_size (float): The proportion of the dataset to include in the test split (0-1).
&lt;span class="k"&gt;-&lt;/span&gt; seed (int): The random seed for reproducibility.

Returns:
&lt;span class="k"&gt;-&lt;/span&gt; X_train (pd.DataFrame): Training input data.
&lt;span class="k"&gt;-&lt;/span&gt; X_test (pd.DataFrame): Testing input data.
&lt;span class="k"&gt;-&lt;/span&gt; y_train (pd.DataFrame or pd.Series): Training output data.
&lt;span class="k"&gt;-&lt;/span&gt; y_test (pd.DataFrame or pd.Series): Testing output data.
&amp;quot;&amp;quot;&amp;quot;
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=seed)

print(f&amp;#39;X train shape: {X_train.shape}&amp;#39;)
print(f&amp;#39;y train shape: {y_train.shape}&amp;#39;)
print(f&amp;#39;X test shape : {X_test.shape}&amp;#39;)
print(f&amp;#39;y test shape : {y_test.shape}\n&amp;#39;)

return X_train, X_test, y_train, y_test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;In[10]:&lt;/h1&gt;
&lt;h1&gt;Split the data&lt;/h1&gt;
&lt;h1&gt;First, split the train &amp;amp; not train&lt;/h1&gt;
&lt;p&gt;X_train, X_not_train, y_train, y_not_train = split_train_test(X, y, test_size=0.2, seed=123) # WRITE YOUR CODE HERE, Use seed=123&lt;/p&gt;
&lt;h1&gt;Then, split the valid &amp;amp; test&lt;/h1&gt;
&lt;p&gt;X_valid, X_test, y_valid, y_test = split_train_test(X_not_train, y_not_train, test_size=0.5, seed=123) # WRITE YOUR CODE HERE, Use seed=123&lt;/p&gt;
&lt;h1&gt;In[11]:&lt;/h1&gt;
&lt;h1&gt;Validate (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;print(len(X_train)/len(X))  # should be 0.8
print(len(X_valid)/len(X))  # should be 0.1
print(len(X_test)/len(X))   # should be 0.1&lt;/p&gt;
&lt;h1&gt;In[12]:&lt;/h1&gt;
&lt;p&gt;X_train.head()  # (JUST RUN THE CODE)&lt;/p&gt;
&lt;h1&gt;#### 2.3. Separate Numerical and Categorical Features (6 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;- We now prepare to perform data preprocessing&lt;/h1&gt;
&lt;h1&gt;- But, we first separate the data into numerical data &amp;amp; categorical data.&lt;/h1&gt;
&lt;h1&gt;In[13]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Create a function to split numerical &amp;amp; categorical input&lt;/h1&gt;
&lt;h1&gt;- you have three parameters&lt;/h1&gt;
&lt;h1&gt;- data, an input data (pd. Dataframe)&lt;/h1&gt;
&lt;h1&gt;- num_cols, a list of numerical columns (list)&lt;/h1&gt;
&lt;h1&gt;- cat_cols, a list of categorical columns (list)&lt;/h1&gt;
&lt;h1&gt;- and write a validation that you perform right operation&lt;/h1&gt;
&lt;h1&gt;- and return two dataframe, numerical &amp;amp; categorical data&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;def split_num_cat(data, num_cols,cat_cols):
    """
    Split the input DataFrame into numerical and categorical DataFrames based on the provided lists of columns.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;Parameters&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;num_cols&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;numerical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;cat_cols&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;categorical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="k"&gt;Returns&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;numerical_cols&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;categorical_cols&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="ss"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="ss"&gt;# Validate that the input columns exist in the DataFrame&lt;/span&gt;
&lt;span class="ss"&gt;for col in num_cols + cat_cols:&lt;/span&gt;
&lt;span class="ss"&gt;    if col not in data.columns:&lt;/span&gt;
&lt;span class="ss"&gt;        raise ValueError(f&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;Column&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;{col}&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;found&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;)&lt;/span&gt;

&lt;span class="ss"&gt;# Validate that there is no overlap between numerical and categorical columns&lt;/span&gt;
&lt;span class="ss"&gt;overlap = set(num_cols).intersection(set(cat_cols))&lt;/span&gt;
&lt;span class="ss"&gt;if overlap:&lt;/span&gt;
&lt;span class="ss"&gt;    raise ValueError(f&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;Columns&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="n"&gt;overlap&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;are&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;present&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;both&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;numerical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;categorical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lists&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Split&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;numerical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;categorical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DataFrames&lt;/span&gt;
&lt;span class="n"&gt;numerical_cols&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_cols&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;categorical_cols&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cat_cols&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Data num shape: {numerical_cols.shape}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Data cat shape: {categorical_cols.shape}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;numerical_cols&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;categorical_cols&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;num_cols = ['pickup_longitude','pickup_latitude','dropoff_longitude','dropoff_latitude','passenger_count']
cat_cols = ['pickup_time']&lt;/p&gt;
&lt;h1&gt;In[14]:&lt;/h1&gt;
&lt;h1&gt;Split the data&lt;/h1&gt;
&lt;p&gt;X_train_num, X_train_cat = split_num_cat(X_train, num_cols, cat_cols) # WRITE YOUR CODE HERE&lt;/p&gt;
&lt;h1&gt;In[15]:&lt;/h1&gt;
&lt;p&gt;X_train_num.head()  # (JUST RUN THE CODE)&lt;/p&gt;
&lt;h1&gt;In[16]:&lt;/h1&gt;
&lt;p&gt;X_train_cat.head()  # (JUST RUN THE CODE)&lt;/p&gt;
&lt;h1&gt;#### EDA before Preprocessing (JUST RUN THE CODE)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;- Find the number of missing values&lt;/h1&gt;
&lt;h1&gt;In[17]:&lt;/h1&gt;
&lt;p&gt;100 * (X_train.isna().sum(0) / len(X_train))&lt;/p&gt;
&lt;h1&gt;- We will impute all these variables if there is any missing value&lt;/h1&gt;
&lt;h1&gt;- First, check the numerical features distribution&lt;/h1&gt;
&lt;h1&gt;In[18]:&lt;/h1&gt;
&lt;p&gt;import matplotlib.pyplot as plt
import seaborn as sns
get_ipython().run_line_magic('matplotlib', 'inline')&lt;/p&gt;
&lt;h1&gt;In[19]:&lt;/h1&gt;
&lt;h1&gt;Plot histogram&lt;/h1&gt;
&lt;p&gt;fig, ax = plt.subplots(nrows=3, ncols=2, figsize=(12, 8))
axes = ax.flatten()&lt;/p&gt;
&lt;p&gt;for i, col in enumerate(X_train_num.columns):
    sns.kdeplot(X_train_num[col], ax=axes[i])
    axes[i].set_title(f'Distribution of {col}')&lt;/p&gt;
&lt;p&gt;plt.tight_layout()
plt.show()&lt;/p&gt;
&lt;h1&gt;- All the distribution are skewed, we can impute a missing value by its features median.&lt;/h1&gt;
&lt;h1&gt;- Next, explore the &lt;code&gt;pickup_time&lt;/code&gt;&lt;/h1&gt;
&lt;h1&gt;In[20]:&lt;/h1&gt;
&lt;p&gt;X_train['pickup_time'].value_counts(normalize=True)&lt;/p&gt;
&lt;h1&gt;- There's a missing value with symbol &lt;code&gt;'-'&lt;/code&gt; in &lt;code&gt;pickup_time&lt;/code&gt;,&lt;/h1&gt;
&lt;h1&gt;- We can impute the missing value with &lt;code&gt;UNKNOWN&lt;/code&gt;&lt;/h1&gt;
&lt;h1&gt;- Explore the relation between &lt;code&gt;pickup_time&lt;/code&gt; and &lt;code&gt;fare&lt;/code&gt;&lt;/h1&gt;
&lt;h1&gt;In[21]:&lt;/h1&gt;
&lt;h1&gt;Concat the data first&lt;/h1&gt;
&lt;p&gt;train_data = pd.concat((X_train, y_train), axis=1)
train_data.head()&lt;/p&gt;
&lt;h1&gt;In[22]:&lt;/h1&gt;
&lt;h1&gt;Create a boxplot&lt;/h1&gt;
&lt;p&gt;sns.boxplot(data=train_data[train_data['fare_amount'] &amp;lt; 50],
            x='pickup_time',
            y='fare_amount')
plt.show()&lt;/p&gt;
&lt;h1&gt;- There is no significant fare different between &lt;code&gt;pickup_time&lt;/code&gt;.&lt;/h1&gt;
&lt;h1&gt;- We can perform a one hot encoding for this data.&lt;/h1&gt;
&lt;h1&gt;&lt;strong&gt;Conclusion for preprocessing&lt;/strong&gt;&lt;/h1&gt;
&lt;h1&gt;- Impute the missing &lt;code&gt;passenger_counts&lt;/code&gt; with its median&lt;/h1&gt;
&lt;h1&gt;- Impute the missing &lt;code&gt;pickup_time&lt;/code&gt; with &lt;code&gt;'UNKNOWN'&lt;/code&gt;&lt;/h1&gt;
&lt;h1&gt;- Feature engineering the &lt;code&gt;dropoff&lt;/code&gt; and &lt;code&gt;pickup&lt;/code&gt; coordinate to be a distance between pickup and dropoff. We can use an Euclidean distance for simplicity.&lt;/h1&gt;
&lt;h1&gt;#### 2.4. Numerical Imputation (6 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;- Now, let's perform a numerical imputation&lt;/h1&gt;
&lt;h1&gt;- First check the missing value of the numerical data&lt;/h1&gt;
&lt;h1&gt;In[23]:&lt;/h1&gt;
&lt;h1&gt;Check missing value (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;X_train_num.isna().sum(0)&lt;/p&gt;
&lt;h1&gt;- Create a function to fit a numerical features imputer&lt;/h1&gt;
&lt;h1&gt;In[24]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Create function to fit &amp;amp; transform numerical imputers&lt;/h1&gt;
&lt;h1&gt;The fit function is called by num_imputer_fit&lt;/h1&gt;
&lt;h1&gt;- it needs 1 input, the data (pd.DataFrame)&lt;/h1&gt;
&lt;h1&gt;- the missing value is np.nan&lt;/h1&gt;
&lt;h1&gt;- the imputation strategy is median&lt;/h1&gt;
&lt;h1&gt;- it return the imputer&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;The transform function is called by num_imputer_transform&lt;/h1&gt;
&lt;h1&gt;- it needs 2 input, data (pd.DataFrame) and imputer (sklearn object)&lt;/h1&gt;
&lt;h1&gt;- it return the imputed data in pd.DataFrame format&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;def num_imputer_fit(data):
    """
    Fit a numerical imputer.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nx"&gt;Parameters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;The&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;DataFrame&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;containing&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;numerical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="nx"&gt;Returns&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;SimpleImputer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;The&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;fitted&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;imputer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;

&lt;span class="nx"&gt;fit_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;SimpleImputer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;strategy&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nx"&gt;median&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;fit_data&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;def num_imputer_transform(data, imputer):
    """
    Transform the numerical data using a fitted imputer.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nx"&gt;Parameters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;The&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;DataFrame&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;containing&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;numerical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;imputer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;SimpleImputer&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;The&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;fitted&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;imputer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="nx"&gt;Returns&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;The&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;DataFrame&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;imputed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;values&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="nx"&gt;transform_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;imputer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;                              &lt;/span&gt;&lt;span class="nx"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;index&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;transform_data&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;- Perform imputation&lt;/h1&gt;
&lt;h1&gt;In[25]:&lt;/h1&gt;
&lt;h1&gt;Get the numerical imputer&lt;/h1&gt;
&lt;p&gt;num_imputer = num_imputer_fit(X_train_num) # WRITE YOUR CODE HERE&lt;/p&gt;
&lt;h1&gt;Transform the data&lt;/h1&gt;
&lt;p&gt;X_train_num_imputed = num_imputer_transform(X_train_num, num_imputer) # WRITE YOUR CODE HERE&lt;/p&gt;
&lt;h1&gt;In[26]:&lt;/h1&gt;
&lt;h1&gt;Validate (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;X_train_num_imputed.isna().sum(0)&lt;/p&gt;
&lt;h1&gt;Great!&lt;/h1&gt;
&lt;h1&gt;#### 2.5. Categorical Imputation (6 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;- Next, let's perform the categorical imputation&lt;/h1&gt;
&lt;h1&gt;In[27]:&lt;/h1&gt;
&lt;h1&gt;Check missing value (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;X_train_cat.value_counts(normalize=True)&lt;/p&gt;
&lt;h1&gt;- Create a function to fit a categorical features imputer&lt;/h1&gt;
&lt;h1&gt;In[28]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Create function to fit &amp;amp; transform categorical imputers&lt;/h1&gt;
&lt;h1&gt;The fit function is called by cat_imputer_fit&lt;/h1&gt;
&lt;h1&gt;- it needs 1 input, the data (pd.DataFrame)&lt;/h1&gt;
&lt;h1&gt;- the missing value is '-'&lt;/h1&gt;
&lt;h1&gt;- the imputation strategy is filling it with 'UNKNOWN'&lt;/h1&gt;
&lt;h1&gt;- it return the imputer&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;The transform function is called by cat_imputer_transform&lt;/h1&gt;
&lt;h1&gt;- it needs 2 input, data (pd.DataFrame) and imputer (sklearn object)&lt;/h1&gt;
&lt;h1&gt;- it return the imputed data in pd.DataFrame format&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;def cat_imputer_fit(data):
    """
    Fits a SimpleImputer for categorical variables.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Parameters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;containing&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;categorical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;variables&lt;/span&gt;

&lt;span class="n"&gt;Returns&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SimpleImputer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Fitted&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;imputer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;fit_data = SimpleImputer(missing_values=&amp;#39;-&amp;#39;,&lt;/span&gt;
&lt;span class="s2"&gt;                         strategy=&amp;#39;constant&amp;#39;,&lt;/span&gt;
&lt;span class="s2"&gt;                         fill_value=&amp;#39;UNKNOWN&amp;#39;)&lt;/span&gt;
&lt;span class="s2"&gt;fit_data.fit(data)&lt;/span&gt;

&lt;span class="s2"&gt;return fit_data&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;def cat_imputer_transform(data, imputer):
    """
    Transforms data using a fitted categorical imputer.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nx"&gt;Parameters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;transform&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;imputer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;SimpleImputer&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Fitted&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;imputer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;object&lt;/span&gt;

&lt;span class="nx"&gt;Returns&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Transformed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;imputed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;values&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="nx"&gt;imputed_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;imputer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;transform_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;imputed_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                              &lt;/span&gt;&lt;span class="nx"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;                              &lt;/span&gt;&lt;span class="nx"&gt;index&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;transform_data&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;- Perform imputation&lt;/h1&gt;
&lt;h1&gt;In[29]:&lt;/h1&gt;
&lt;h1&gt;Perform categorical imputation&lt;/h1&gt;
&lt;p&gt;cat_imputer = cat_imputer_fit(X_train_cat) # WRITE YOUR CODE HERE&lt;/p&gt;
&lt;h1&gt;Transform&lt;/h1&gt;
&lt;p&gt;X_train_cat_imputed = cat_imputer_transform(X_train_cat, cat_imputer) # WRITE YOUR CODE HERE&lt;/p&gt;
&lt;h1&gt;In[30]:&lt;/h1&gt;
&lt;h1&gt;Validate (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;X_train_cat_imputed.value_counts(normalize=True)&lt;/p&gt;
&lt;h1&gt;In[31]:&lt;/h1&gt;
&lt;p&gt;X_train_cat_imputed.head()&lt;/p&gt;
&lt;h1&gt;Great!&lt;/h1&gt;
&lt;h1&gt;#### 2.6. Preprocess Categorical Features (6 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;- We will create a one-hot-encoder (read the &lt;code&gt;EDA before processing&lt;/code&gt;) for the categorical features&lt;/h1&gt;
&lt;h1&gt;- Create a function to perform a one hot encoder&lt;/h1&gt;
&lt;h1&gt;In[32]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Write two functions to perform OHE for the categorical data&lt;/h1&gt;
&lt;h1&gt;The first function is called cat_encoder_fit&lt;/h1&gt;
&lt;h1&gt;- It needs 1 input, the data (pd.DataFrame)&lt;/h1&gt;
&lt;h1&gt;- You create an encoder (from OHE Sklearn)&lt;/h1&gt;
&lt;h1&gt;- input all categories of the categorical data&lt;/h1&gt;
&lt;h1&gt;- if there is other category outside the categories listed right now, ignore it&lt;/h1&gt;
&lt;h1&gt;- return the encoder&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;The second function is called cat_encoder_transfrom&lt;/h1&gt;
&lt;h1&gt;- It needs two input, the data (pd.DataFrame), the encoder (sklearn object)&lt;/h1&gt;
&lt;h1&gt;- It transform the input data based on the encoder&lt;/h1&gt;
&lt;h1&gt;- It returns the encoded data (pd.DataFrame)&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;def cat_encoder_fit(data):
    """
    Fit a OneHotEncoder for categorical data.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Parameters:
&lt;span class="k"&gt;-&lt;/span&gt; data (pd.DataFrame): The input DataFrame containing categorical data.

Returns:
&lt;span class="k"&gt;-&lt;/span&gt; OneHotEncoder: The fitted encoder.
&amp;quot;&amp;quot;&amp;quot;
encoder = OneHotEncoder(sparse_output=False)
fit_data = encoder.fit(data[[&amp;#39;pickup_time&amp;#39;]])

return fit_data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;def cat_encoder_transform(data, encode):
    """
    Transform the categorical data using a fitted encoder.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Parameters:
&lt;span class="k"&gt;-&lt;/span&gt; data (pd.DataFrame): The input DataFrame containing categorical data.
&lt;span class="k"&gt;-&lt;/span&gt; encode (OneHotEncoder): The fitted encoder.

Returns:
&lt;span class="k"&gt;-&lt;/span&gt; pd.DataFrame: The transformed data as a DataFrame.
&amp;quot;&amp;quot;&amp;quot;
encoder = encode
encoded = encoder.transform(data)
transform_data = pd.DataFrame(encoded, columns=encoder.categories_[0])
transform_data.index = data.index

return transform_data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;- Perform imputation&lt;/h1&gt;
&lt;h1&gt;In[33]:&lt;/h1&gt;
&lt;h1&gt;Perform categorical imputation&lt;/h1&gt;
&lt;p&gt;cat_encoder = cat_encoder_fit(X_train_cat_imputed) # WRITE YOUR CODE HERE&lt;/p&gt;
&lt;h1&gt;Transform&lt;/h1&gt;
&lt;p&gt;X_train_cat_encoded = cat_encoder_transform(X_train_cat_imputed, cat_encoder) # WRITE YOUR CODE HERE&lt;/p&gt;
&lt;h1&gt;In[34]:&lt;/h1&gt;
&lt;h1&gt;Validate  (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;print('Original shape:', X_train_cat_imputed.shape)
print('Encoded shape :', X_train_cat_encoded.shape)&lt;/p&gt;
&lt;h1&gt;In[35]:&lt;/h1&gt;
&lt;h1&gt;Validate  (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;X_train_cat_encoded.head()&lt;/p&gt;
&lt;h1&gt;In[36]:&lt;/h1&gt;
&lt;h1&gt;Validate  (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;X_train_cat_imputed.head()&lt;/p&gt;
&lt;h1&gt;Great!&lt;/h1&gt;
&lt;h1&gt;#### 2.7. Join the data (6 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;- After all the data is filled (numerically), we can join the data&lt;/h1&gt;
&lt;h1&gt;- Create a function to join the data&lt;/h1&gt;
&lt;h1&gt;In[37]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Create a function to join / concat the data&lt;/h1&gt;
&lt;h1&gt;The function is called by concat_data&lt;/h1&gt;
&lt;h1&gt;- It needs two input, num_data (pd.DataFrame) and cat_data (pd.DataFrame)&lt;/h1&gt;
&lt;h1&gt;- Don't forget to validate your process&lt;/h1&gt;
&lt;h1&gt;- It returns the concated data&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;def concat_data(num_data, cat_data):
    """
    Concatenate numerical and categorical data.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Parameters:
&lt;span class="k"&gt;-&lt;/span&gt; num_data (pd.DataFrame): DataFrame containing numerical data.
&lt;span class="k"&gt;-&lt;/span&gt; cat_data (pd.DataFrame): DataFrame containing categorical data.

Returns:
&lt;span class="k"&gt;-&lt;/span&gt; pd.DataFrame: Concatenated DataFrame.
&amp;quot;&amp;quot;&amp;quot;
concated_data = pd.concat([num_data, cat_data], axis=1)

print(f&amp;#39;Numerical data shape  : {num_data.shape}&amp;#39;)
print(f&amp;#39;Categorical data shape: {cat_data.shape}&amp;#39;)
print(f&amp;#39;Concat data shape     : {concated_data.shape}&amp;#39;)

return concated_data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;- Perform concatenated&lt;/h1&gt;
&lt;h1&gt;In[38]:&lt;/h1&gt;
&lt;h1&gt;Concat the data&lt;/h1&gt;
&lt;p&gt;X_train_concat = concat_data(X_train_num_imputed, X_train_cat_encoded) # WRITE YOUR CODE HERE&lt;/p&gt;
&lt;h1&gt;In[39]:&lt;/h1&gt;
&lt;h1&gt;Validate (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;X_train_concat.head()&lt;/p&gt;
&lt;h1&gt;Great!&lt;/h1&gt;
&lt;h1&gt;#### 2.8. Feature engineering the data (8 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;- Now, &lt;code&gt;pickup&lt;/code&gt; and &lt;code&gt;dropoff&lt;/code&gt; coordinate is not an explicit features.&lt;/h1&gt;
&lt;h1&gt;- We can create a better feature called by &lt;code&gt;distance&lt;/code&gt; to summarize the &lt;code&gt;pickup&lt;/code&gt; and &lt;code&gt;dropoff&lt;/code&gt; coordinate.&lt;/h1&gt;
&lt;h1&gt;In[40]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Create a function that obtain the distance&lt;/h1&gt;
&lt;h1&gt;The function is called with map_distance&lt;/h1&gt;
&lt;h1&gt;- It needs an input, data (pd.DataFrame)&lt;/h1&gt;
&lt;h1&gt;- In the input, you calculate the trip distance using Euclidean Distance&lt;/h1&gt;
&lt;h1&gt;ref: https://www.cuemath.com/euclidean-distance-formula/&lt;/h1&gt;
&lt;h1&gt;- Then, you can save the distance information as a new column, 'distance'&lt;/h1&gt;
&lt;h1&gt;- And you can drop the pickup and dropoff latitude and longitude&lt;/h1&gt;
&lt;h1&gt;- You return the mapped data&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;def map_distance(data):
    """
    Calculate the Euclidean distance between pickup and dropoff points
    and add it as a new column. Drop latitude and longitude columns.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Parameters:
&lt;span class="k"&gt;-&lt;/span&gt; data (pd.DataFrame): DataFrame containing latitude and longitude information. 
            Must include columns: &amp;#39;pickup_latitude&amp;#39;, &amp;#39;pickup_longitude&amp;#39;, 
            &amp;#39;dropoff_latitude&amp;#39;, &amp;#39;dropoff_longitude&amp;#39;.

Returns:
&lt;span class="k"&gt;-&lt;/span&gt; pd.DataFrame: DataFrame with a new column &amp;#39;distance&amp;#39; and without latitude/longitude columns.
&amp;quot;&amp;quot;&amp;quot;
data[&amp;#39;distance&amp;#39;] = np.sqrt(
    (data[&amp;#39;dropoff_latitude&amp;#39;] - data[&amp;#39;pickup_latitude&amp;#39;])**2 +
    (data[&amp;#39;dropoff_longitude&amp;#39;] - data[&amp;#39;pickup_longitude&amp;#39;])**2
)

data.drop(columns=[&amp;#39;dropoff_latitude&amp;#39;,&amp;#39;pickup_latitude&amp;#39;,&amp;#39;dropoff_longitude&amp;#39;,&amp;#39;pickup_longitude&amp;#39;], inplace=True)

return data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;- Perform distance calculation (4 pts)&lt;/h1&gt;
&lt;h1&gt;In[41]:&lt;/h1&gt;
&lt;h1&gt;Calculate the distance&lt;/h1&gt;
&lt;p&gt;X_train_concat_fe = map_distance(X_train_concat) # WRITE YOUR CODE HERE&lt;/p&gt;
&lt;h1&gt;In[42]:&lt;/h1&gt;
&lt;h1&gt;Validate (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;X_train_concat_fe.head()&lt;/p&gt;
&lt;h1&gt;- And finally, we standardize the data so that it can perform well during model optimization (4 pts)&lt;/h1&gt;
&lt;h1&gt;In[43]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Create two functions to perform scaling &amp;amp; transform scaling&lt;/h1&gt;
&lt;h1&gt;The scaling is Standardization&lt;/h1&gt;
&lt;h1&gt;The first function is to fit the scaler, called by fit_scaler&lt;/h1&gt;
&lt;h1&gt;- You need an input, a data (pd.Dataframe)&lt;/h1&gt;
&lt;h1&gt;- You create a standardization scaler (please use sklearn)&lt;/h1&gt;
&lt;h1&gt;- Your output is the scaler&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;The second function is to transform data using scaler, called by transform_scaler&lt;/h1&gt;
&lt;h1&gt;- There are two inputs, a data (pd.Dataframe), a scaler (sklearn object)&lt;/h1&gt;
&lt;h1&gt;- You scaled the data, then return the scaled data&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;def fit_scaler(data):
    """
    Fit a StandardScaler to the given data.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Parameters:
&lt;span class="k"&gt;-&lt;/span&gt; data (pd.DataFrame): The input data to fit the scaler.

Returns:
&lt;span class="k"&gt;-&lt;/span&gt; StandardScaler: The fitted scaler.
&amp;quot;&amp;quot;&amp;quot;
fit_data = StandardScaler().fit(data)

return fit_data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;def transform_scaler(data, scaled):
    """
    Transform the given data using the fitted scaler.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Parameters:
&lt;span class="k"&gt;-&lt;/span&gt; data (pd.DataFrame): The input data to be transformed.
&lt;span class="k"&gt;-&lt;/span&gt; scaled (StandardScaler): The fitted scaler.

Returns:
&lt;span class="k"&gt;-&lt;/span&gt; pd.DataFrame: Scaled data in the same format as the input DataFrame.
&amp;quot;&amp;quot;&amp;quot;
transformed_data = scaled.transform(data)
transform_data = pd.DataFrame(transformed_data, columns=data.columns, index=data.index)

return transform_data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;In[44]:&lt;/h1&gt;
&lt;h1&gt;Fit the scaler&lt;/h1&gt;
&lt;p&gt;scaler = fit_scaler(X_train_concat_fe) # WRITE YOUR CODE HERE&lt;/p&gt;
&lt;h1&gt;Transform the scaler&lt;/h1&gt;
&lt;p&gt;X_train_clean = transform_scaler(X_train_concat_fe, scaler) # WRITE YOUR CODE HERE&lt;/p&gt;
&lt;h1&gt;In[45]:&lt;/h1&gt;
&lt;h1&gt;Validate (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;X_train_clean.describe().round(4)&lt;/p&gt;
&lt;h1&gt;Great!&lt;/h1&gt;
&lt;h1&gt;#### 2.9. Create the preprocess function (10 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;- Now, let's create a function to preprocess other set of data (valid &amp;amp; test) so that we can predict that&lt;/h1&gt;
&lt;h1&gt;In[46]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Create a function to preprocess the dataset&lt;/h1&gt;
&lt;h1&gt;You called the function preprocess_data&lt;/h1&gt;
&lt;h1&gt;- It needs many input&lt;/h1&gt;
&lt;h1&gt;- data, pd.DataFrame&lt;/h1&gt;
&lt;h1&gt;- num_cols, the numerical columns, list&lt;/h1&gt;
&lt;h1&gt;- cat_cols, the categorical columns, list&lt;/h1&gt;
&lt;h1&gt;- num_imputer, the numerical imputer, sklearn object&lt;/h1&gt;
&lt;h1&gt;- cat_imputer, the categorical imputer, sklearn object&lt;/h1&gt;
&lt;h1&gt;- cat_encoder, the categorical encoder, sklearn object&lt;/h1&gt;
&lt;h1&gt;- scaler, the data scaler, sklearn object&lt;/h1&gt;
&lt;h1&gt;- You preprocess the data following step 2.3 - 2.8&lt;/h1&gt;
&lt;h1&gt;- You return the clean data&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;def preprocess_data(data, num_cols, cat_cols, num_imputer, cat_imputer, cat_encoder, scaler):
    """
    Preprocess the dataset by imputing missing values, encoding categorical variables, and scaling numerical variables.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;Parameters&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;num_cols&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;numerical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;cat_cols&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;categorical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;num_imputer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sklearn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;object&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;numerical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;imputer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;cat_imputer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sklearn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;object&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;categorical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;imputer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;cat_encoder&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sklearn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;object&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;categorical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;scaler&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sklearn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;object&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;scaler&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="k"&gt;Returns&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;clean_data&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;preprocessed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="ss"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="ss"&gt;# Validate that the input columns exist in the DataFrame&lt;/span&gt;
&lt;span class="ss"&gt;for col in num_cols + cat_cols:&lt;/span&gt;
&lt;span class="ss"&gt;    if col not in data.columns:&lt;/span&gt;
&lt;span class="ss"&gt;        raise ValueError(f&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;Column&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;{col}&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;found&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;)&lt;/span&gt;

&lt;span class="ss"&gt;# Validate that there is no overlap between numerical and categorical columns&lt;/span&gt;
&lt;span class="ss"&gt;overlap = set(num_cols).intersection(set(cat_cols))&lt;/span&gt;
&lt;span class="ss"&gt;if overlap:&lt;/span&gt;
&lt;span class="ss"&gt;    raise ValueError(f&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;Columns&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="n"&gt;overlap&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;are&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;present&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;both&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;numerical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;categorical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lists&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Split&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;numerical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;categorical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DataFrames&lt;/span&gt;
&lt;span class="n"&gt;X_train_num&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_cols&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;X_train_cat&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cat_cols&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Fit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;numerical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;features&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;imputer&lt;/span&gt;
&lt;span class="n"&gt;num_imputed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_imputer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X_train_num&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;                              &lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;X_train_num&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;index&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;X_train_num&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Numerical data shape  : {num_imputed.shape}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Fit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;categorical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;features&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;imputer&lt;/span&gt;
&lt;span class="n"&gt;cat_imputed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cat_imputer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X_train_cat&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;                              &lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;X_train_cat&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;                              &lt;/span&gt;&lt;span class="k"&gt;index&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;X_train_cat&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Create&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;hot&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;categorical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;features&lt;/span&gt;
&lt;span class="n"&gt;cat_encoded&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cat_encoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cat_imputed&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;cat_encoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;categories_&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;cat_encoded&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cat_imputed&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Categorical data shape: {cat_encoded.shape}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Join&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;
&lt;span class="n"&gt;concated_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_imputed, cat_encoded&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;axis&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Concat data shape     : {concated_data.shape}\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Original data shape: {concated_data.shape}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Create&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;better&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;feature&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;summarize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pickup&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dropoff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;coordinate&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;concated_data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;&amp;#39;distance&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concated_data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;&amp;#39;dropoff_latitude&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;concated_data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;&amp;#39;pickup_latitude&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concated_data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;&amp;#39;dropoff_longitude&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;concated_data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;&amp;#39;pickup_longitude&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;concated_data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;drop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;=[&lt;/span&gt;&lt;span class="n"&gt;&amp;#39;dropoff_latitude&amp;#39;,&amp;#39;pickup_latitude&amp;#39;,&amp;#39;dropoff_longitude&amp;#39;,&amp;#39;pickup_longitude&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inplace&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Standardize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;can&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;perform&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;well&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;during&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;optimization&lt;/span&gt;
&lt;span class="n"&gt;clean_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scaler&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concated_data&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;concated_data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;index&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;concated_data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Mapped data shape  : {clean_data.shape}\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clean_data&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;num_cols = ['pickup_longitude','pickup_latitude','dropoff_longitude','dropoff_latitude','passenger_count']
cat_cols = ['pickup_time']&lt;/p&gt;
&lt;h1&gt;In[47]:&lt;/h1&gt;
&lt;h1&gt;Preprocess the data training again&lt;/h1&gt;
&lt;p&gt;X_train_clean = preprocess_data(data=X_train,
                                num_cols=num_cols, 
                                cat_cols=cat_cols, 
                                num_imputer=num_imputer, 
                                cat_imputer=cat_imputer, 
                                cat_encoder=cat_encoder, 
                                scaler=scaler) # WRITE YOUR CODE HERE &lt;/p&gt;
&lt;h1&gt;In[48]:&lt;/h1&gt;
&lt;h1&gt;Validate (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;print('Original data shape:', X_train.shape)
print('Cleaned data shape :', X_train_clean.shape)
X_train_clean.head()&lt;/p&gt;
&lt;h1&gt;In[49]:&lt;/h1&gt;
&lt;h1&gt;Transform other set of data&lt;/h1&gt;
&lt;p&gt;X_valid_clean = preprocess_data(data=X_valid,
                                num_cols=num_cols, 
                                cat_cols=cat_cols, 
                                num_imputer=num_imputer, 
                                cat_imputer=cat_imputer, 
                                cat_encoder=cat_encoder, 
                                scaler=scaler)# WRITE YOUR CODE HERE
X_test_clean = preprocess_data(data=X_test,
                                num_cols=num_cols, 
                                cat_cols=cat_cols, 
                                num_imputer=num_imputer, 
                                cat_imputer=cat_imputer, 
                                cat_encoder=cat_encoder, 
                                scaler=scaler)# WRITE YOUR CODE HERE&lt;/p&gt;
&lt;h1&gt;### 3. Training Machine Learning Models (40 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;```&lt;/h1&gt;
&lt;h1&gt;3.1 Prepare train &amp;amp; evaluate model function&lt;/h1&gt;
&lt;h1&gt;3.2 Train &amp;amp; evaluate several models&lt;/h1&gt;
&lt;h1&gt;3.3 Choose the best model&lt;/h1&gt;
&lt;h1&gt;```&lt;/h1&gt;
&lt;h1&gt;#### 3.1. Preprare train &amp;amp; evaluate model function (10 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;- Before modeling, let's prepare function to train &amp;amp; evaluate model&lt;/h1&gt;
&lt;h1&gt;In[50]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;First, create a function to train model called train_model&lt;/h1&gt;
&lt;h1&gt;- It needs 3 input&lt;/h1&gt;
&lt;h1&gt;- estimator, the model (sklearn model)&lt;/h1&gt;
&lt;h1&gt;- X_train, the input (pd.DataFrame)&lt;/h1&gt;
&lt;h1&gt;- y_train, the output (pd.DataFrame)&lt;/h1&gt;
&lt;h1&gt;- You only fit the estimator using the X_train &amp;amp; y_train&lt;/h1&gt;
&lt;h1&gt;- Then return nothing&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;Next, create a function to evaluate model called evaluate_model&lt;/h1&gt;
&lt;h1&gt;- It needs 5 input&lt;/h1&gt;
&lt;h1&gt;- estimator, the model (sklearn model)&lt;/h1&gt;
&lt;h1&gt;- X_train, the train input (pd.DataFrame)&lt;/h1&gt;
&lt;h1&gt;- y_train, the train output (pd.DataFrame)&lt;/h1&gt;
&lt;h1&gt;- X_valid, the valid input (pd.DataFrame)&lt;/h1&gt;
&lt;h1&gt;- y_valid, the valid output (pd.DataFrame)&lt;/h1&gt;
&lt;h1&gt;- You calculate the model performance using root mean squared error metrics&lt;/h1&gt;
&lt;h1&gt;- Then return two output, rmse_train and rmse_valid&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;def train_model(estimator, X_train, y_train):
    """
    Train the model on the training data.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Parameters:
&lt;span class="k"&gt;-&lt;/span&gt; model: sklearn model, the model to be trained.
&lt;span class="k"&gt;-&lt;/span&gt; X_train: pd.DataFrame, the training input data.
&lt;span class="k"&gt;-&lt;/span&gt; y_train: pd.Series, the training target data.
&amp;quot;&amp;quot;&amp;quot;
estimator.fit(X_train, y_train)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;def evaluate_model(estimator, X_train, y_train, X_valid, y_valid):
    """
    Evaluate the model on the training and test data.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Parameters:
&lt;span class="k"&gt;-&lt;/span&gt; model: sklearn model, the trained model.
&lt;span class="k"&gt;-&lt;/span&gt; X_train: pd.DataFrame, the training input data.
&lt;span class="k"&gt;-&lt;/span&gt; y_train: pd.Series, the training target data.
&lt;span class="k"&gt;-&lt;/span&gt; X_test: pd.DataFrame, the test input data.
&lt;span class="k"&gt;-&lt;/span&gt; y_test: pd.Series, the test target data.

Returns:
&lt;span class="k"&gt;-&lt;/span&gt; rmse_train: float, the RMSE on the training data.
&lt;span class="k"&gt;-&lt;/span&gt; rmse_test: float, the RMSE on the test data.
&amp;quot;&amp;quot;&amp;quot;
&lt;span class="gh"&gt;#&lt;/span&gt; Make predictions
y_train_pred = estimator.predict(X_train)
y_valid_pred = estimator.predict(X_valid)

&lt;span class="gh"&gt;#&lt;/span&gt; Calculate RMSE for training data
rmse_train = np.sqrt(mean_squared_error(y_train, y_train_pred))

&lt;span class="gh"&gt;#&lt;/span&gt; Calculate RMSE for validation data
rmse_valid = np.sqrt(mean_squared_error(y_valid, y_valid_pred))

return rmse_train, rmse_valid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;#### 3.2. Train and Evaluate Several Models (10 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;- Now, let's train &amp;amp; evaluate several models&lt;/h1&gt;
&lt;h1&gt;- You should check, which one of the following model is the best model&lt;/h1&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;1. Baseline model&lt;/h1&gt;
&lt;h1&gt;2. k-NN with k=1&lt;/h1&gt;
&lt;h1&gt;3. k-NN with k=100&lt;/h1&gt;
&lt;h1&gt;4. k-NN with k=200&lt;/h1&gt;
&lt;h1&gt;5. k-NN with k=500&lt;/h1&gt;
&lt;h1&gt;6. k-NN with k=len(data)&lt;/h1&gt;
&lt;h1&gt;In[52]:&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Create your model here (no need to create function)&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;reg_1 = DummyRegressor(strategy='mean')               # Write your code here, follow the description
reg_2 = KNeighborsRegressor(n_neighbors=1)            # Write your code here, follow the description
reg_3 = KNeighborsRegressor(n_neighbors=100)          # Write your code here, follow the description
reg_4 = KNeighborsRegressor(n_neighbors=200)          # Write your code here, follow the description
reg_5 = KNeighborsRegressor(n_neighbors=500)          # Write your code here, follow the description
reg_6 = KNeighborsRegressor(n_neighbors=len(X_test_clean))         # Write your code here, follow the description&lt;/p&gt;
&lt;h1&gt;In[53]:&lt;/h1&gt;
&lt;h1&gt;Train the model (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;train_model(reg_1, X_train_clean, y_train)
train_model(reg_2, X_train_clean, y_train)
train_model(reg_3, X_train_clean, y_train)
train_model(reg_4, X_train_clean, y_train)
train_model(reg_5, X_train_clean, y_train)
train_model(reg_6, X_train_clean, y_train)&lt;/p&gt;
&lt;h1&gt;In[1]:&lt;/h1&gt;
&lt;h1&gt;Return validation (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;import time&lt;/p&gt;
&lt;p&gt;for reg in [reg_1, reg_2, reg_3, reg_4, reg_5, reg_6]:
    t0 = time.time()&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Generate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rmse&lt;/span&gt;
&lt;span class="n"&gt;rmse_train&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rmse_valid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;evaluate_model&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;estimator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                                        &lt;/span&gt;&lt;span class="n"&gt;X_train&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;X_train_clean&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                                        &lt;/span&gt;&lt;span class="n"&gt;y_train&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;y_train&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                                        &lt;/span&gt;&lt;span class="n"&gt;X_valid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;X_valid_clean&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                                        &lt;/span&gt;&lt;span class="n"&gt;y_valid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;y_valid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Logging&lt;/span&gt;
&lt;span class="n"&gt;elapsed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t0&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;40&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;RMSE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;train:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nl"&gt;rmse_train:&lt;/span&gt;&lt;span class="mf"&gt;.4f&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;RMSE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;valid:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nl"&gt;rmse_valid:&lt;/span&gt;&lt;span class="mf"&gt;.4f&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Time&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;elapsed:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;elapsed&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;.2f&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ms&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;#### 3.3. Choose the best model (20 pts)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;From the previous results, which one is the best model? (10 pts)&lt;/h1&gt;
&lt;h1&gt;```&lt;/h1&gt;
&lt;h1&gt;model : KNeighborsRegressor(n_neighbors=100)     | RMSE train: 3.9594 | RMSE valid: 3.9783 | Time elapsed: 78513.55 ms&lt;/h1&gt;
&lt;h1&gt;```&lt;/h1&gt;
&lt;h1&gt;Why do you choose that model? (10 pts)&lt;/h1&gt;
&lt;h1&gt;```&lt;/h1&gt;
&lt;h1&gt;Because this model has a good balance between training and validation RMSE, with a relatively low RMSE on both datasets.&lt;/h1&gt;
&lt;h1&gt;- Lowest validation RMSE&lt;/h1&gt;
&lt;h1&gt;- Very small gap between train and valid RMSE&lt;/h1&gt;
&lt;h1&gt;```&lt;/h1&gt;
&lt;h1&gt;And, create a &lt;code&gt;reg_best&lt;/code&gt; to store the best model&lt;/h1&gt;
&lt;h1&gt;In[ ]:&lt;/h1&gt;
&lt;h1&gt;Write your code here&lt;/h1&gt;
&lt;p&gt;reg_best = KNeighborsRegressor(n_neighbors=100) 
reg_best.fit(X_train_clean, y_train) # Write your code here&lt;/p&gt;
&lt;h1&gt;### 4. Predictions &amp;amp; Evaluations (JUST RUN THE CODE)&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;```&lt;/h1&gt;
&lt;h1&gt;4.1 Predict &amp;amp; Evaluate on the Train Data&lt;/h1&gt;
&lt;h1&gt;4.2 Predict &amp;amp; Evaluate on the Test Data&lt;/h1&gt;
&lt;h1&gt;```&lt;/h1&gt;
&lt;h1&gt;#### 4.1. Predict &amp;amp; evaluate on train data&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;In[ ]:&lt;/h1&gt;
&lt;h1&gt;Predict (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;y_train_pred = reg_best.predict(X_train_clean)&lt;/p&gt;
&lt;h1&gt;In[ ]:&lt;/h1&gt;
&lt;h1&gt;Visualize &amp;amp; compare the prediction (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;plt.scatter(y_train, y_train_pred)&lt;/p&gt;
&lt;p&gt;plt.plot([0, 200], [0, 200], c='red')
plt.xlim(0, 200); plt.ylim(0, 200)
plt.xlabel('y actual'); plt.ylabel('y predicted')
plt.title('Comparison of y actual vs y predicted on Train Data')
plt.show()&lt;/p&gt;
&lt;h1&gt;#### 4.2. Predict &amp;amp; evaluate on test data&lt;/h1&gt;
&lt;h1&gt;---&lt;/h1&gt;
&lt;h1&gt;In[ ]:&lt;/h1&gt;
&lt;h1&gt;Predict (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;y_test_pred = reg_best.predict(X_test_clean)&lt;/p&gt;
&lt;h1&gt;In[ ]:&lt;/h1&gt;
&lt;h1&gt;Visualize &amp;amp; compare the prediction (JUST RUN THE CODE)&lt;/h1&gt;
&lt;p&gt;plt.scatter(y_test, y_test_pred)&lt;/p&gt;
&lt;p&gt;plt.plot([0, 200], [0, 200], c='red')
plt.xlim(0, 200); plt.ylim(0, 200)
plt.xlabel('y actual'); plt.ylabel('y predicted')
plt.title('Comparison of y actual vs y predicted on Test Data')
plt.show()&lt;/p&gt;</content><category term="machine learning"></category><category term="machine learning"></category><category term="jupyterlab"></category><category term="data science"></category></entry><entry><title>Learn Python #2</title><link href="http://localhost:8000/2024/07/learn-python-2/" rel="alternate"></link><published>2024-07-03T11:20:00+07:00</published><updated>2024-07-03T11:20:00+07:00</updated><author><name>0xbugbag</name></author><id>tag:localhost,2024-07-03:/2024/07/learn-python-2/</id><summary type="html">&lt;p&gt;In this post, I have written code to find fibonacci-prime number.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;&lt;strong&gt;Code&lt;/strong&gt; &lt;img alt="Python Image" height="100" src="http://localhost:8000/images/python-logo.png" width="100"&gt;&lt;/h2&gt;
&lt;p&gt;Syntax highlighting&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_fibo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fibo_nth&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="sd"&gt;    This function is used to get Fibonacci numbers.&lt;/span&gt;

&lt;span class="sd"&gt;    Parameters:&lt;/span&gt;
&lt;span class="sd"&gt;    - fibo_nth (int): Fibonacci numbers n-th F(n-th) as arguments&lt;/span&gt;

&lt;span class="sd"&gt;    Returns:&lt;/span&gt;
&lt;span class="sd"&gt;    - lst_fibo (int): the list consists of Fibonacci numbers&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;fnum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;# n=1, F1&lt;/span&gt;
    &lt;span class="n"&gt;snum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;# n=2, F2&lt;/span&gt;
    &lt;span class="n"&gt;lst_fibo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="c1"&gt;# an empty list&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;fibo_nth&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# The Fibonacci sequence&lt;/span&gt;
        &lt;span class="nb"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fnum&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;snum&lt;/span&gt; &lt;span class="c1"&gt;# According to the recurrence: sum, fnum and snum&lt;/span&gt;
        &lt;span class="n"&gt;fnum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;snum&lt;/span&gt; &lt;span class="c1"&gt;# Then, shift fnum to snum&lt;/span&gt;
        &lt;span class="n"&gt;snum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt; &lt;span class="c1"&gt;# Shift snum to sum, the operation will loop until fn&lt;/span&gt;
        &lt;span class="n"&gt;lst_fibo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# Append the sum to lst_fibo&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;lst_fibo&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_prime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="sd"&gt;    This function is used to get prime numbers.&lt;/span&gt;

&lt;span class="sd"&gt;    Parameters:&lt;/span&gt;
&lt;span class="sd"&gt;    - num (int): fibonacci numbers as arguments&lt;/span&gt;

&lt;span class="sd"&gt;    Returns:&lt;/span&gt;
&lt;span class="sd"&gt;    - prime numbers (int): consist of prime numbers&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;# To eliminate 0 and 1, not prime&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;# To eliminate even numbers, not prime&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt; &lt;span class="c1"&gt;# Return prime numbers&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fibonacci_prime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="sd"&gt;    This function is used to get the first `n` Fibonacci primes.&lt;/span&gt;
&lt;span class="sd"&gt;    If `n` is less than 1 the return is invalid, since Fibonacci and primes numbers cannot be negative integers&lt;/span&gt;

&lt;span class="sd"&gt;    Parameters:&lt;/span&gt;
&lt;span class="sd"&gt;    - head (int): first numbers n-th as arguments&lt;/span&gt;

&lt;span class="sd"&gt;    Returns:&lt;/span&gt;
&lt;span class="sd"&gt;    - lst (int): the first `n` of th Fibonacci prime numbers&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;lst_first_n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="c1"&gt;# Empty list to store Fibonacci primes&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fibo_prime&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
            &lt;span class="n"&gt;lst_first_n&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fibo_prime&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;        
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="c1"&gt;# Since Fibonacci and primes numbers cannot be negative integers&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Invalid number. Should be greater than 0&amp;#39;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;lst_first_n&lt;/span&gt;

&lt;span class="c1"&gt;# Define a varibale of Fibonacci numbers n-th F(n-th)&lt;/span&gt;
&lt;span class="n"&gt;fibo_nth&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;43&lt;/span&gt;

&lt;span class="c1"&gt;# Call get_fibo function&lt;/span&gt;
&lt;span class="n"&gt;fibo_num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_fibo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fibo_nth&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Call get_prime function within list comprehension to get list of Fibonacci prime numbers&lt;/span&gt;
&lt;span class="n"&gt;fibo_prime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;fibo_num&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;get_prime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;

&lt;span class="c1"&gt;# Input number to print result of n-th numbers&lt;/span&gt;
&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Input n-numbers: &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;# Call fibonacci_prime function to get the first `n` of th Fibonacci prime numbers&lt;/span&gt;
&lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fibonacci_prime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Print result&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;fibonacci_prime(n = &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="python"></category><category term="python"></category></entry><entry><title>Learn Markdown</title><link href="http://localhost:8000/2024/07/learn-markdown/" rel="alternate"></link><published>2024-07-03T10:20:00+07:00</published><updated>2024-07-03T11:20:00+07:00</updated><author><name>0xbugbag</name></author><id>tag:localhost,2024-07-03:/2024/07/learn-markdown/</id><summary type="html">&lt;p&gt;In this article, I have written my first article using Markdown.&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is an example from &lt;a href="https://markdown-it.github.io/" target="_blank"&gt;https://markdown-it.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;h1 Heading&lt;/h1&gt;
&lt;h2&gt;h2 Heading&lt;/h2&gt;
&lt;h3&gt;h3 Heading&lt;/h3&gt;
&lt;h4&gt;h4 Heading&lt;/h4&gt;
&lt;h5&gt;h5 Heading&lt;/h5&gt;
&lt;h6&gt;h6 Heading&lt;/h6&gt;
&lt;h2&gt;Horizontal Rules&lt;/h2&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;h2&gt;Emphasis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;This is bold text&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This is bold text&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This is italic text&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This is italic text&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;~~Strikethrough~~&lt;/p&gt;
&lt;h2&gt;Blockquotes&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Blockquotes can also be nested...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;...by using additional greater-than signs right next to each other...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;...or with spaces between arrows.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Lists&lt;/h2&gt;
&lt;p&gt;Unordered&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create a list by starting a line with &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Sub-lists are made by indenting 2 spaces:&lt;/li&gt;
&lt;li&gt;Marker character change forces new list start:&lt;ul&gt;
&lt;li&gt;Ac tristique libero volutpat at&lt;/li&gt;
&lt;li&gt;Facilisis in pretium nisl aliquet&lt;/li&gt;
&lt;li&gt;Nulla volutpat aliquam velit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Very easy!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ordered&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Lorem ipsum dolor sit amet&lt;/li&gt;
&lt;li&gt;Consectetur adipiscing elit&lt;/li&gt;
&lt;li&gt;Integer molestie lorem at massa&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;p&gt;Inline &lt;code&gt;code&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Indented code&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Some comments&lt;/span&gt;
&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;
&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;
&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Block code "fences"&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Sample text here...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Syntax highlighting&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;numbers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Tables&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Option&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;data&lt;/td&gt;
&lt;td&gt;path to data files to supply the data that will be passed into templates.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;engine&lt;/td&gt;
&lt;td&gt;engine to be used for processing templates. Handlebars is the default.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ext&lt;/td&gt;
&lt;td&gt;extension to be used for dest files.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Right aligned columns&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: right;"&gt;Option&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: right;"&gt;data&lt;/td&gt;
&lt;td style="text-align: right;"&gt;path to data files to supply the data that will be passed into templates.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: right;"&gt;engine&lt;/td&gt;
&lt;td style="text-align: right;"&gt;engine to be used for processing templates. Handlebars is the default.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: right;"&gt;ext&lt;/td&gt;
&lt;td style="text-align: right;"&gt;extension to be used for dest files.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Links&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://dev.nodeca.com"&gt;link text&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://nodeca.github.io/pica/demo/" title="title text!"&gt;link with title&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Images&lt;/h2&gt;</content><category term="markdown"></category><category term="pelican"></category><category term="markdown"></category></entry><entry><title>Belajar Python #1</title><link href="http://localhost:8000/2024/07/under-construction/" rel="alternate"></link><published>2024-07-03T10:20:00+07:00</published><updated>0024-07-03T13:50:00+07:07</updated><author><name>0xbugbag</name></author><id>tag:localhost,2024-07-03:/2024/07/under-construction/</id><summary type="html">&lt;p&gt;Under Construction&lt;/p&gt;</summary><content type="html">&lt;p&gt;Under Construction&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;         \      ____
    ()   /\   __|   |
  /|  |\/  __|      |
   |/\|   |         |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;</content><category term="python"></category><category term="pelican"></category><category term="python"></category></entry></feed>